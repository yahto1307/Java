# 数据库缓存一致性
### 提出问题
> 业务中经常会遇到大量的读多写少的场景，如果每次读操作都从数据库中获取，不仅耗时(磁盘io+网络传输)而且当发生大量读操作的时候会影响到数据库的性能(**单个mysql的并发量最好控制在2000内)**。因此会把需要经常读取的数据放入缓存(本地缓存，缓存服务器都可以，这里以缓存服务器redis为例)。这样读操作就可以直接从缓存中读取数据(内存数据库，耗时在网络传输)，不必再去读取数据库。数据放入缓存，这样就有了两份数据，处理不当可能会导致数据库与缓存的数据不一致。
假设数据库中有X=1这个数据
1.A线程读取缓存，cache miss，A线程读取数据库数据，此时读到 X = 1
2.B线程更新数据库，set X = 2
3.A线程将 X = 1 放入缓存
假设没有设置 X 的过期时间，那么其他后面的读取操作都只能读到 X = 1

------------
### 是改修改缓存，还是淘汰缓存
> 1. 修改数据和删除数据有什么差别
	1. 淘汰某个key，操作简单，直接将key置为无效，但下一次该key的访问会cache miss
	2. 修改某个key的内容，逻辑相对复杂，但下一次该key的访问仍会cache hit
可以看到，**差异仅仅在于一次cache miss**
1. 缓存中的value数据一般是怎么修改的
	1. 朴素类型的数据，直接set修改后的值即可
	2. 序列化后的对象：一般需要先get数据，反序列化成对象，修改其中的成员，再序列化为binary，再set数据
	3. json或者html数据：一般也需要先get文本，parse成doom树对象，修改相关元素，序列化为文本，再set数据
对于对象类型，或者文本类型，修改缓存value的成本较高，一般选择直接淘汰缓存。
1. 复杂计算后的数据缓存该直接删除
	如果采用更新缓存，那么再更新数据库后，还要经过一些列的复杂计算查表等，请直接删除缓存，让发生cache miss，降低业务复杂度。
1. **如果实在不会选，那就删缓存，多一次cache miss而已**

------------

### CAP(Cache Aside Pattern)方案
1. 读操作：先读取缓存，若cache miss，则读取数据库，最后把数据写入缓存
1. 更新操作：先更新数据库，然后删除缓存
facebook似乎是这么用的。
1. 方案存在的问题